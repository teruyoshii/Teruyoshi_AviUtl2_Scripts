@main
--text@text:式,
--check@_isDebug:デバッグを有効,1
if _isDebug == 1 then isDebug = true else isDebug = false end

color_metaTable = {
  typeName = "color",

  __index = function(t, k)
    debug_print("unknown key " .. k .." in table " .. tostring(t))
  end,
  __tostring = function(t)
    return "color(" .. t[1]*255 .. ", " .. t[2]*255 .. ", " .. t[3]*255 .. ")"
  end,
  __add = function(a, b) -- 加算
    if type(a) == "table" and type(b) == "table" then -- 色と色の加算
      if getmetatable(a) == nil or getmetatable(a).typeName ~= "color" then
        debug_print("warning: adding a non-color table " .. table.concat(a, ", "))
      end
      if getmetatable(b) == nil or getmetatable(b).typeName ~= "color" then
        debug_print("warning: adding a non-color table " .. table.concat(b, ", "))
      end
      local result = setmetatable({}, color_metaTable)
      for i = 1, 3 do
        result[i] = a[i] + b[i]
      end
      if isDebug then debug_print("added two colors            : " .. tostring(a) .. " + " .. tostring(b) .. " = " .. tostring(result)) end
      return result

    elseif (type(a) == "table" and type(b) == "number") or (type(a) == "number" and type(b) == "table") then -- 色と数値の加算
      local result = setmetatable({}, color_metaTable)
      if type(a) == "number" then a, b = b, a end -- aをtableにする
      for i = 1, #a do
        result[i] = a[i] + b
      end
      if isDebug then debug_print("added color and number      : " .. tostring(a) .. " + " .. tostring(b) .. " = " .. tostring(result)) end
      return result
    
    elseif (type(a) == "string" and type(b) == "string") then -- バッファとバッファの加算
          --TODO: バッファとバッファの加算処理を追加
      return a
    
    elseif (type(a) == "string" and type(b) == "table") then -- バッファと色の加算
      obj.pixelshader("BufAddCol", a, a, b)
      if isDebug then debug_print("added buffer and color      : " .. tostring(a) .. " + " .. tostring(b) .. " = " .. tostring(result)) end
      return a
    else
      debug_print("invalid addition between " .. getmetatable(a).typeName or "unknown" .. " and " .. getmetatable(b).typeName or "unknown")
      return nil
    end
  end,

  __sub = function(a, b) -- 減算
    if type(a) == "table" and type(b) == "table" then -- 色と色の減算
      local result = setmetatable({}, color_metaTable)
      for i = 1, math.max(#a, #b) do
        result[i] = (a[i] or 0) - (b[i] or 0)
      end
      if isDebug then debug_print("subtracted two colors       : " .. tostring(a) .. " - " .. tostring(b) .. " = " .. tostring(result)) end
      return result

    elseif (type(a) == "table" and type(b) == "number") or (type(a) == "number" and type(b) == "table") then -- 色と数値の減算
      local result = setmetatable({}, color_metaTable)
      if type(a) == "number" then 
        --TODO: 数値 - 色 の場合の処理を追加
      end -- aをtableにする
      for i = 1, #a do
        result[i] = a[i] - b
      end
      if isDebug then debug_print("subtracted color and number : " .. tostring(a) .. " - " .. tostring(b) .. " = " .. tostring(result)) end
      return result
    
    elseif (type(a) == "string" and type(b) == "string") then -- バッファとバッファの減算
      --TODO: バッファとバッファの減算処理を追加

    elseif (type(a) == "string" and type(b) == "table") then -- バッファと色の減算
      if isDebug then debug_print("subtracted buffer and color : " .. tostring(a) .. " - " .. tostring(b)) end
      obj.pixelshader("BufSubCol", a, a, b)
      return a

    else
      debug_print("invalid subtraction between " .. type(a) .. " and " .. type(b))
      return nil
    end
  end,

  __mul = function(a, b) -- 乗算
    if type(a) == "table" and type(b) == "table" then -- 色と色の乗算
      local result = setmetatable({}, color_metaTable)
      for i = 1, math.max(#a, #b) do
        result[i] = (a[i] or 0) * (b[i] or 0)
      end
      if isDebug then debug_print("multiplied two colors       : " .. tostring(a) .. " * " .. tostring(b) .. " = " .. tostring(result)) end
      return result

    elseif (type(a) == "table" and type(b) == "number") or (type(a) == "number" and type(b) == "table") then -- 色と数値の乗算
      local result = setmetatable({}, color_metaTable)
      if type(a) == "number" then a, b = b, a end -- aをtableにする
      for i = 1, #a do
        result[i] = a[i] * b
      end
      if isDebug then debug_print("multiplied color and number : " .. tostring(a) .. " * " .. tostring(b) .. " = " .. tostring(result)) end
      return result

    elseif (type(a) == "string" and type(b) == "string") then -- バッファとバッファの乗算
      --TODO: バッファとバッファの乗算処理を追加
      return a
    elseif (type(a) == "string" and type(b) == "table") then -- バッファと色の乗算
      if isDebug then debug_print("multiplied buffer and color : " .. tostring(a) .. " * " .. tostring(b)) end
      obj.pixelshader("BufMulCol", a, a, b)
      return a
    else
      debug_print("invalid multiplication between " .. type(a) .. " and " .. type(b))
      return nil
    end
  end
}


-- pixelshader呼び出しデバッグ用
function pixelshader(name, target, resource, constants)
  if isDebug ==1 then
    debug_print("Call \""..name .."\" for \"" ..target .."\" reference \"" ..resource .."\" with (" ..constants[1]*255 ..", "..constants[2]*255 ..", "..constants[3]*255 ..")")
  end
end

--[[pixelshader@BufAddCol:
Texture2D tex : register(t0);
cbuffer constant0 : register(b0) {
  float3 col;
};
SamplerState samLinear : register(s0);
struct PS_INPUT {
  float4 pos : SV_Position;
  float2 uv : TEXCOORD0;
};
float4 BufAddCol(PS_INPUT input) : SV_Target {
  float4 original_col = tex.Sample(samLinear, input.uv);
  return float4(original_col.rgb + col*original_col.a, original_col.a);
}
]]
--[[pixelshader@BufSubCol:
Texture2D tex : register(t0);
cbuffer constant0 : register(b0) {
  float3 col;
};
SamplerState samLinear : register(s0);
struct PS_INPUT {
  float4 pos : SV_Position;
  float2 uv : TEXCOORD0;
};
float4 BufSubCol(PS_INPUT input) : SV_Target {
  float4 original_col = tex.Sample(samLinear, input.uv);
  return float4(original_col.rgb - col*original_col.a, original_col.a);
}
]]
--[[pixelshader@BufMulCol:
Texture2D tex : register(t0);
cbuffer constant0 : register(b0) {
  float3 col;
};
SamplerState samLinear : register(s0);
struct PS_INPUT {
  float4 pos : SV_Position;
  float2 uv : TEXCOORD0;
};
float4 BufMulCol(PS_INPUT input) : SV_Target {
  float4 original_col = tex.Sample(samLinear, input.uv);
  return float4(original_col.rgb * col, original_col.a);
}
]]

target = "object" -- ピクセルシェーダーの結果の出力先
resource = "object" -- ピクセルシェーダーの参照するバッファ名

function hex2Color(col) --カラーコードをfloat3(最大値1のRGB)に変換
  local r,g,b = RGB(col)
  return setmetatable({r / 255.0, g / 255.0, b / 255.0}, color_metaTable)
end
function color(r, g, b) -- float3(最大値1のRGB)を生成
  debug_print("color function called      : color(" .. r .. ", " .. g .. ", " .. b .. ")")
  return setmetatable({r/255, g/255, b/255}, color_metaTable)
end

function defineColor(pairs) -- {変数名, 値}の配列を受け取り、グローバル変数として定義する
  for _, pair in ipairs(pairs) do
    local name, value = pair[1], pair[2]
    if type(value) == "table" then
      _G[name] = setmetatable(value, color_metaTable)
    else
      _G[name] = setmetatable(hex2Color(value), color_metaTable)
    end
    if isDebug then debug_print("Defined color variable      : " .. name .. " = " .. tostring(_G[name])) end
  end
end

function defineValue(pairs) -- {変数名, 値}の配列を受け取り、グローバル変数として定義する
  for _, pair in ipairs(pairs) do
    local name, value = pair[1], pair[2]
    _G[name] = value
    if isDebug then debug_print("Defined value variable      : " .. name .. " = " .. tostring(_G[name])) end
  end
end

function typeName2metaTable(typeName) -- 型名からメタテーブルを返す
  if typeName == "color" then
    return color_metaTable
  else
    return nil
  end
end

defineColor(ES_col or {})
defineValue(ES_val or {})

-- f に数式文字列を入れる
local textExpressions = {}
if text then --textのnullチェック
  for line in tostring(text):gmatch("([^\r\n]+)") do --textを行ごとに取り出してfに格納
    if line ~= "" then table.insert(textExpressions, line) end
  end
end

function f_apply(f) -- textの各行を解釈して実行
  if f:match("^//") or f:match("^%-%-") then -- コメント行は無視
    return
  elseif f:match("=") then -- 変数宣言
    local left, right = f:match("^(.+)%s+=%s+(.+)$")
    debug_print("Processing assignment      : " .. left .. "=" .. right)
    local type, name = left:match("^(.+)%s+(.+)$") -- 変数名と型名を抽出
    _G[name] = setmetatable(load("return " .. right)(), color_metaTable) -- 色変数として定義
    if isDebug then debug_print("Set variable                : " .. left .. " = " .. tostring(_G[name])) end
  else -- 式
    local expr, err = load("return " .. f)
    if not expr then
      debug_print("Error in expression: " .. f .. " - " .. err)
      return
    end
    return expr()
  end
end
--色と値の登録用配列を初期化
_G[ES_col]={}
_G[ES_val]={}

for _, f in ipairs(textExpressions) do
  f_apply(f)
end

if isDebug then debug_print("完了") end

@色登録
--color@col:col,0xff0000
--value@name:name,"col1"
if ES_col == nil then
  ES_col={}
  table.insert(ES_col, {name, col})
  return
else
  for i, pair in ipairs(ES_col) do
    local n, v = pair[1], pair[2]
    if n == name then
      --debug_print("Warning: Duplicate color name " .. name .. ". Overwriting previous value.")
      ES_col[i] = {name, col}
      return
    end
  end
  table.insert(ES_col, {name, col})
end

@値登録 [-1~1]
--track@val:val,-1,1,0,0.01
--value@name:name,"var1"
if ES_val == nil then
  ES_val={}
  table.insert(ES_val, {name, val})
else
  for i, pair in ipairs(ES_val) do
    local n, v = pair[1], pair[2]
    if n == name then
      --debug_print("Warning: Duplicate value name " .. name .. ". Overwriting previous value.")
      ES_val[i] = {name, val}
      return
    end
  end
  table.insert(ES_val, {name, val})
end