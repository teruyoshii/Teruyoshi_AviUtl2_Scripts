--information:ãƒã‚¤ã‚ºã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ v1.2 by teruyoshi
-- Azuriteã•ã‚“ã®ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³+(https://github.com/azurite581/AviUtl2-GradientPlus)ã‚’å‚è€ƒã«ä½œæˆã—ã¾ã—ãŸ
--track@str:å¼·ã•,0,100,100,0.01
--track@sizeX:ãƒ‰ãƒƒãƒˆã‚µã‚¤ã‚ºX,1,100,1,0.01
--track@sizeY:ãƒ‰ãƒƒãƒˆã‚µã‚¤ã‚ºY,1,100,1,0.01
--track@cx:ä¸­å¿ƒX,-5000,5000,0,0.01
--track@cy:ä¸­å¿ƒY,-5000,5000,0,0.01
--track@angle_deg:è§’åº¦/å†…å¾„,-3600,3600,0,0.01
--track@width:å¹…,0,2000,300,0.01
--select@shape:å½¢çŠ¶=0,ç·šå½¢=0,å††å½¢=1
--track0:ğŸ•’ï¸ï½¸ï¾ï¾—ï¾ƒï¾æ›²ç·š0â†’100,0,100,0,0.01 --æ™‚é–“åˆ¶å¾¡ã§ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ã®é·ç§»ã‚’åˆ¶å¾¡ã™ã‚‹
--color@rgb1:é–‹å§‹è‰²,0xff0000
--track@a1:é–‹å§‹è‰²é€æ˜åº¦,0,100,0,0.01
--color@rgb2:çµ‚äº†è‰²,0x0000ff
--track@a2:çµ‚äº†è‰²é€æ˜åº¦,0,100,0,0.01
--select@blendMode:åˆæˆãƒ¢ãƒ¼ãƒ‰=0,é€šå¸¸=0,åŠ ç®—=1,æ¸›ç®—=2,ä¹—ç®—=3,ã‚¹ã‚¯ãƒªãƒ¼ãƒ³=4,ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤=5,æ¯”è¼ƒ(æ˜)=6,æ¯”è¼ƒ(æš—)=7,è¼åº¦=8,è‰²å·®=9,é™°å½±=10,æ˜æš—=11,å·®åˆ†=12,ã‚¢ãƒ«ãƒ•ã‚¡åŠ ç®—=13,ã‚¢ãƒ«ãƒ•ã‚¡æœ€å¤§å€¤=14,ã‚¢ãƒ«ãƒ•ã‚¡æ¸›ç®—=15,ã‚¢ãƒ«ãƒ•ã‚¡åŠ ç®—2=16
--track@seed:ã‚·ãƒ¼ãƒ‰,0,10000,0,1
--check@clear:å…ƒã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ã‚¯ãƒªã‚¢,0
local resolution = 256 -- ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ã‚«ãƒ¼ãƒ–ã®è§£åƒåº¦

local BM = {"none", "add", "sub", "mul", "screen", "overlay", "light", "dark", "brightness", "chroma", "shadow", "light_dark", "diff", "alpha_add", "alpha_max", "alpha_sub", "alpha_add2"}

--[[pixelshader@noiseGradient:
  static const uint resolution = 256; //ä¸Šã®resolutionã¨åˆã‚ã›ã‚‹ã“ã¨
  Texture2D tex : register(t0);
  cbuffer constant0 : register(b0) {
    float str;
    float2 center;
    float angle;
    float width;
    float3 rgb1;
    float a1;
    float3 rgb2;
    float a2;
    uint shape;
    float2 size;
    uint seed;
    float gCurve[resolution];
  };
  SamplerState samLinear : register(s0);
  struct PS_INPUT {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
  };

  // å‚è€ƒ: https://andantesoft.hatenablog.com/entry/2024/12/19/193517
  float ibukiHash(uint4 u) { 
    // posã¨seedã‚’ã‚‚ã¨ã«ã€0ã€œ1ã®ç–‘ä¼¼ä¹±æ•°ã‚’ç”Ÿæˆ
    const uint4 mult = uint4(0xae3cc725, 0x9fe72885, 0xae36bfb5, 0x82c1fcad);  
    u = u * mult;  
    u ^= u.wxyz ^ u >> 13;  
    uint r = dot(u, mult);  
    r ^= r >> 11;  
    r = (r * r) ^ r;  
    return r * 2.3283064365386962890625e-10;  
  }  
  float4 noiseGradient(PS_INPUT input) : SV_Target {
    float original_a = tex.Sample(samLinear, input.uv).a; // å…ƒã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®é€æ˜åº¦
    float4 rgba1 = float4(rgb1 * original_a*a1, a1 * original_a);
    float4 rgba2 = float4(rgb2 * original_a*a2, a2 * original_a);
    float rand = ibukiHash(uint4(input.pos.x, input.pos.y, input.pos.z, input.pos.w + seed));
    float d;
    if (shape == 0) { // ç·šå½¢
      d = dot(input.pos.xy - center, float2(cos(angle), sin(angle))) + width/2.0;
    }
    else { // å††å½¢
      d = length(float2((input.pos.x - center.x) * size.x, (input.pos.y - center.y) * size.y)) - angle; // angleã¯å††å½¢ã®å ´åˆåŠå¾„ã¨ã—ã¦æµç”¨
    }
    if (d < 0 ) return rgba1;
    if (d > width ) return rgba2;
    float mapped_d = gCurve[floor((d)/width * resolution/4)];
    return (mapped_d > rand) ? rgba2 : rgba1;
  }
]]

--ï½¸ï¾ï¾—ï¾ƒï¾æ›²ç·šã‹ã‚‰ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ã‚«ãƒ¼ãƒ–ã®é…åˆ—ã‚’ä½œæˆ
local gCurves = {}
if obj.getoption("track_mode", "0") == 0 then -- æ™‚é–“åˆ¶å¾¡ãŒè¨­å®šã•ã‚Œã¦ã„ãªã„å ´åˆã¯ç›´ç·šç§»å‹•ã¨ã¿ãªã™
  for i = 0, resolution+2 do
    gCurves[i] = i/(resolution+2)
  end
else
  for i = 0, resolution+2 do
    gCurves[i] = obj.getvalue(0,(obj.totaltime-1/obj.framerate)*i/(resolution+2))/100
  end
end

local r1 , g1, b1 = RGB(rgb1)
local r2 , g2, b2 = RGB(rgb2)
obj.setoption("drawtarget", "tempbuffer", obj.w, obj.h)
if clear == 0 then
  obj.draw()
end
obj.effect("ãƒªã‚µã‚¤ã‚º", "æ‹¡å¤§ç‡", 100, "X", 100/sizeX, "Y", 100/sizeY, "è£œé–“ãªã—", 1, "ãƒ”ã‚¯ã‚»ãƒ«æ•°ã§ã‚µã‚¤ã‚ºæŒ‡å®š", 0)
local angle = angle_deg/180*math.pi + 1e-10  -- è§’åº¦ãŒã¡ã‚‡ã†ã©90åº¦ã‚„270åº¦ã®ã¨ãã®0é™¤ç®—å›é¿
-- ãƒªã‚µã‚¤ã‚ºã®å½±éŸ¿ã‚’è€ƒæ…®ã—ã¦è§’åº¦ã‚’è£œæ­£
if shape == 0 then
  local sign = 0 -- atanã§æ¶ˆãˆã‚‹ç¬¦å·æƒ…å ±ã‚’ä¿å­˜
  if (angle_deg+90)%360 > 180 then
    sign = math.pi
  end
  angle = math.atan(sizeX/sizeY * math.tan(angle))+sign+math.pi/2
  -- å¹…ã‚’ãƒªã‚µã‚¤ã‚ºã®å½±éŸ¿ã‚’è€ƒæ…®ã—ã¦è£œæ­£
  width = width * math.sqrt((math.cos(angle)/sizeX)^2 + (math.sin(angle)/sizeY)^2)
else
  angle = angle_deg/2 -- å††å½¢ã®å ´åˆã¯è§’åº¦ã‚’å†…å¾„ã¨ã—ã¦æµç”¨
  width = width/2 -- å††å½¢ã®å ´åˆã¯ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼å´ã§ã‚‚è£œæ­£ã™ã‚‹
end
-- ä¸­å¿ƒåº§æ¨™ã‚’ãƒªã‚µã‚¤ã‚ºã®å½±éŸ¿ã‚’è€ƒæ…®ã—ã¦è£œæ­£
cx = cx/sizeX + obj.w / 2
cy = cy/sizeY + obj.h / 2
obj.pixelshader("noiseGradient", "object", "object", {
    str/100.0,
    cx, cy,
    angle,
    width,
    r1/255.0, g1/255.0, b1/255.0,
    1-a1/100.0,
    r2/255.0, g2/255.0, b2/255.0,
    1-a2/100.0,
    shape,
    sizeX, sizeY,
    math.floor(seed),
    unpack(gCurves)
  },
  "copy"
)
obj.effect("ãƒªã‚µã‚¤ã‚º", "æ‹¡å¤§ç‡", 100, "X", sizeX*100, "Y", sizeY*100, "è£œé–“ãªã—", 1, "ãƒ”ã‚¯ã‚»ãƒ«æ•°ã§ã‚µã‚¤ã‚ºæŒ‡å®š", 0)
obj.setoption("blend", BM[blendMode+1])
obj.draw(0,0,0,1.0,str/100.0)
obj.setoption("blend", "none")
obj.copybuffer("obj","tmp")
