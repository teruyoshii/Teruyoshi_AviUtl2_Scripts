--information:ãƒã‚¤ã‚ºã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ v1.0 by teruyoshi
-- Azuriteã•ã‚“ã®ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³+(https://github.com/azurite581/AviUtl2-GradientPlus)ã‚’å‚è€ƒã«ä½œæˆã—ã¾ã—ãŸ
--track@str:å¼·ã•,0,100,100,0.01
--track@cx:ä¸­å¿ƒX,-5000,5000,0,0.01
--track@cy:ä¸­å¿ƒY,-5000,5000,0,0.01
--track@angle:è§’åº¦/å†…å¾„,-3600,3600,0,0.01
--track@width:å¹…,0,2000,300,0.01
--select@shape:å½¢çŠ¶=0,ç·šå½¢=0,å††å½¢=1
--track0:ğŸ•’ï¸ï½¸ï¾ï¾—ï¾ƒï¾æ›²ç·š0â†’1,0,100,0,0.01 --æ™‚é–“åˆ¶å¾¡ã§ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ã®é·ç§»ã‚’åˆ¶å¾¡ã™ã‚‹
--color@rgb1:é–‹å§‹è‰²,0xff0000
--track@a1:é–‹å§‹è‰²é€æ˜åº¦,0,100,0,0.01
--color@rgb2:çµ‚äº†è‰²,0x0000ff
--track@a2:çµ‚äº†è‰²é€æ˜åº¦,0,100,0,0.01
--select@blendMode:åˆæˆãƒ¢ãƒ¼ãƒ‰=0,é€šå¸¸=0,åŠ ç®—=1,æ¸›ç®—=2,ä¹—ç®—=3,ã‚¹ã‚¯ãƒªãƒ¼ãƒ³=4,ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤=5,æ¯”è¼ƒ(æ˜)=6,æ¯”è¼ƒ(æš—)=7,è¼åº¦=8,è‰²å·®=9,é™°å½±=10,æ˜æš—=11,å·®åˆ†=12,ã‚¢ãƒ«ãƒ•ã‚¡åŠ ç®—=13,ã‚¢ãƒ«ãƒ•ã‚¡æœ€å¤§å€¤=14,ã‚¢ãƒ«ãƒ•ã‚¡æ¸›ç®—=15,ã‚¢ãƒ«ãƒ•ã‚¡åŠ ç®—2=16
--track@seed:ã‚·ãƒ¼ãƒ‰,0,10000,0,1
--check@clear:å…ƒã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ã‚¯ãƒªã‚¢,0
local resolution = 256 -- ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ã‚«ãƒ¼ãƒ–ã®è§£åƒåº¦

local BM = {"none", "add", "sub", "mul", "screen", "overlay", "light", "dark", "brightness", "chroma", "shadow", "light_dark", "diff", "alpha_add", "alpha_max", "alpha_sub", "alpha_add2"}

--[[pixelshader@noiseGradient:
  static const uint resolution = 256; //ä¸Šã®resolutionã¨åˆã‚ã›ã‚‹ã“ã¨
  Texture2D tex : register(t0);
  cbuffer constant0 : register(b0) {
    float str;
    float2 center;
    float angle;
    float width;
    float3 rgb1;
    float a1;
    float3 rgb2;
    float a2;
    uint shape;
    uint seed;
    float gCurve[resolution];
  };
  SamplerState samLinear : register(s0);
  struct PS_INPUT {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
  };

  // å‚è€ƒ: https://andantesoft.hatenablog.com/entry/2024/12/19/193517
  float ibukiHash(float4 v) { 
    // posã¨seedã‚’ã‚‚ã¨ã«ã€0ã€œ1ã®ç–‘ä¼¼ä¹±æ•°ã‚’ç”Ÿæˆ
    const uint4 mult = uint4(0xae3cc725, 0x9fe72885, 0xae36bfb5, 0x82c1fcad);  
    uint4 u = uint4(v);  
    u = u * mult;  
    u ^= u.wxyz ^ u >> 13;  
    uint r = dot(u, mult);  
    r ^= r >> 11;  
    r = (r * r) ^ r;  
    return r * 2.3283064365386962890625e-10;  
  }  
  float4 noiseGradient(PS_INPUT input) : SV_Target {
    float original_a = tex.Sample(samLinear, input.uv).a; // å…ƒã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®é€æ˜åº¦
    float4 rgba1 = float4(rgb1 * original_a*a1, a1 * original_a);
    float4 rgba2 = float4(rgb2 * original_a*a2, a2 * original_a);
    float rand = ibukiHash(input.pos + float4(0,0,0,seed));
    float d;
    if (shape == 0) { // ç·šå½¢
      d = dot(input.pos.xy - center, float2(cos(angle), sin(angle))) + width/2.0;
    }
    else { // å††å½¢
      d = length(input.pos.xy - center) - (angle/3.141592*180 - 90); // angleã¯å††å½¢ã®å ´åˆåŠå¾„ã¨ã—ã¦æµç”¨
    }
    if (d < 0 ) return rgba1;
    if (d > width ) return rgba2;
    float mapped_d = gCurve[floor((d)/width * resolution/4)];
    return (mapped_d > rand) ? rgba2 : rgba1;
  }
]]

--ï½¸ï¾ï¾—ï¾ƒï¾æ›²ç·šã‹ã‚‰ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ã‚«ãƒ¼ãƒ–ã®é…åˆ—ã‚’ä½œæˆ
local gCurves = {}
if obj.getoption("track_mode", "0") == 0 then -- æ™‚é–“åˆ¶å¾¡ãŒè¨­å®šã•ã‚Œã¦ã„ãªã„å ´åˆã¯ç›´ç·šç§»å‹•ã¨ã¿ãªã™
  for i = 0, resolution+2 do
    gCurves[i] = i/(resolution+2)
  end
else
  for i = 0, resolution+2 do
    gCurves[i] = obj.getvalue(0,(obj.totaltime-1/obj.framerate)*i/(resolution+2))/100
  end
end

local r1 , g1, b1 = RGB(rgb1)
local r2 , g2, b2 = RGB(rgb2)
cx = cx + obj.w / 2
cy = cy + obj.h / 2
if clear == 0 then
  obj.draw()
end
obj.pixelshader("noiseGradient", "object", "object", {
    str/100.0,
    cx, cy,
    (angle+90)/180*math.pi,
    width,
    r1/255.0, g1/255.0, b1/255.0,
    1-a1/100.0,
    r2/255.0, g2/255.0, b2/255.0,
    1-a2/100.0,
    shape,
    math.floor(seed),
    unpack(gCurves)
  },
  "copy"
)

obj.setoption("blend", BM[blendMode+1])
obj.draw(0,0,0,1.0,str/100.0)
obj.setoption("blend", "none")
