@座標
--information:座標@離散化　v0
--track@baseX:X最小単位,0,1000,50,0.01
--track@baseY:Y最小単位,0,1000,50,0.01
--track@baseZ:Z最小単位,0,1000,50,0.01
--track@dx:X基準,-500,500,0,0.01
--track@dy:Y基準,-500,500,0,0.01
--track@dz:Z基準,-500,500,0,0.01
if baseX > 0.01 then
  obj.ox = obj.ox - (obj.ox+obj.x-dx) % baseX
end
if baseY > 0.01 then
  obj.oy = obj.oy - (obj.oy+obj.y-dy) % baseY
end
if baseZ > 0.01 then
  obj.oz = obj.oz - (obj.oz+obj.z-dz) % baseZ
end

@回転
--information:回転@離散化　v0
--track@baseX:X最小単位,0,360,15,0.01
--track@baseY:Y最小単位,0,360,15,0.01
--track@baseZ:Z最小単位,0,360,15,0.01
--track@dx:X基準,-180,180,0,0.01
--track@dy:Y基準,-180,180,0,0.01
--track@dz:Z基準,-180,180,0,0.01
if baseX > 0.01 then
  obj.rx = obj.rx - (obj.rx+obj.getvalue("rx")-dx) % baseX
end
if baseY > 0.01 then
  obj.ry = obj.ry - (obj.ry+obj.getvalue("ry")-dy) % baseY
end
if baseZ > 0.01 then
  obj.rz = obj.rz - (obj.rz+obj.getvalue("rz")-dz) % baseZ
end

@透明度 
--information:透明度@離散化　v0
--track@base:最小単位(%),0,100,5,0.01
--track@d:基準(%),-100,100,0,0.01
if base <= 0.01 then
  return
end
EPSILON = 0.0001
local a = obj.alpha*obj.getvalue("alpha")
local new_alpha
if a < EPSILON then
  new_alpha = 0
else
  new_alpha = (a - ((a*100-d-EPSILON) % base) / 100.0 + base/100.0 -EPSILON/100) / obj.getvalue("alpha")
end
obj.alpha =  math.max(0, new_alpha)

@拡大率
--information:拡大率@離散化　v0
--select@mode:方式=0,拡大率の比を使う=0,拡大率の差を使う=1
--track@base:最小単位(%),0,1000,150,0.01
--track@d:基準(%),-500,500,100,0.01
if mode == 0 then -- 等比数列 d * base^nにおいて最も近いサイズにする
  base = base / 100.0
  if base - 1 <= 0.01 then
    return
  end
  if d == 0 then
    d = 100
  end
  if d < 0 then
    d = d*-1
  end
  local s = obj.zoom*obj.getvalue("zoom")
  if (base < 1) then
    base = 1/base
  end
  local new_zoom = 100
  while new_zoom > s do
    new_zoom = new_zoom/base
  end
  while new_zoom*base < s do
    new_zoom = new_zoom*base
  end
  local dif1 = math.abs(new_zoom - s)
  local dif2 = math.abs(new_zoom*base - s)
  if dif1 > dif2 then
    new_zoom = new_zoom*base
  end
  obj.zoom = new_zoom/obj.getvalue("zoom")
else -- 等差数列 d + n*baseにおいて最も近いサイズにする
  if base <= 0.01 then
    return
  end
  obj.zoom = math.max(0, obj.zoom - ((obj.zoom*obj.getvalue("zoom")-d) % base)/obj.getvalue("zoom"))
end




