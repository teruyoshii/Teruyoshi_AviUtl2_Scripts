--information:æ®µéšã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ v1.0 by teruyoshi
-- Azuriteã•ã‚“ã®ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³+(https://github.com/azurite581/AviUtl2-GradientPlus)ã‚’å‚è€ƒã«ä½œæˆã—ã¾ã—ãŸ
--track@str:å¼·ã•,0,100,100,0.01
--track0:ä¸­å¿ƒX,-5000,5000,0,0.01
--track1:ä¸­å¿ƒY,-5000,5000,0,0.01
--track@angle_deg:è§’åº¦/å†…å¾„,-3600,3600,0,0.01
--track@width:å¹…,0,2000,300,0.01
--select@shape:å½¢çŠ¶=0,ç·šå½¢=0,å††å½¢=1
--track@step:æ®µéšæ•°,0,100,5,1 
--track3:ğŸ•’ï¸ï½¸ï¾ï¾—ï¾ƒï¾æ›²ç·š0â†’100,0,100,0,0.01 --æ™‚é–“åˆ¶å¾¡ã§ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ã®é·ç§»ã‚’åˆ¶å¾¡ã™ã‚‹
--color@rgb1:é–‹å§‹è‰²,0xffffff
--track@a1:é–‹å§‹è‰²é€æ˜åº¦,0,100,0,0.01
--color@rgb2:çµ‚äº†è‰²,0x000000
--track@a2:çµ‚äº†è‰²é€æ˜åº¦,0,100,0,0.01
--select@colorSpace:è‰²ç©ºé–“=0,RGB=0,HSLçŸ­çµŒè·¯=1,HSLé•·çµŒè·¯=2,HSLå³å›ã‚Š=3,HSLå·¦å›ã‚Š=4
--select@blendMode:åˆæˆãƒ¢ãƒ¼ãƒ‰=0,é€šå¸¸=0,åŠ ç®—=1,æ¸›ç®—=2,ä¹—ç®—=3,ã‚¹ã‚¯ãƒªãƒ¼ãƒ³=4,ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤=5,æ¯”è¼ƒ(æ˜)=6,æ¯”è¼ƒ(æš—)=7,è¼åº¦=8,è‰²å·®=9,é™°å½±=10,æ˜æš—=11,å·®åˆ†=12,ã‚¢ãƒ«ãƒ•ã‚¡åŠ ç®—=13,ã‚¢ãƒ«ãƒ•ã‚¡æœ€å¤§å€¤=14,ã‚¢ãƒ«ãƒ•ã‚¡æ¸›ç®—=15,ã‚¢ãƒ«ãƒ•ã‚¡åŠ ç®—2=16
--check@clear:å…ƒã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ã‚¯ãƒªã‚¢,0

local MaxResolution = 100 -- ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ã‚«ãƒ¼ãƒ–ã®è§£åƒåº¦
-- é‡ã„å ´åˆã¯MaxResolutionã‚’ä¸‹ã’ã¦ãã ã•ã„(ä¸‹ã®ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼å´ã®MaxResolutionã‚‚åŒã˜å€¤ã«ã—ã¦ãã ã•ã„)
local BM = {"none", "add", "sub", "mul", "screen", "overlay", "light", "dark", "brightness", "chroma", "shadow", "light_dark", "diff", "alpha_add", "alpha_max", "alpha_sub", "alpha_add2"}
local num = obj.setanchor("track", 0, "line")
for i = 0, num - 1 do
	cx = obj.getvalue(0)
	cy = obj.getvalue(1)
end


--[[pixelshader@stepGradient:
  static const uint MaxResolution = 100; // ä¸Šã®Luaå´ã®Maxresolutionã¨åŒã˜å€¤ã«ã™ã‚‹ã“ã¨

  float4 rgb2hsl(float4 rgba) {
    float r = rgba.r;
    float g = rgba.g;
    float b = rgba.b;
    float maxc = max(r, max(g, b));
    float minc = min(r, min(g, b));
    float h = 0.0;
    float s = 0.0;
    float l = (maxc + minc) / 2.0;
    if (maxc != minc) {
      float delta = maxc - minc;
      if (l < 0.5) s = delta / (maxc + minc);
      else s = delta / (2.0 - maxc - minc);
      if (maxc == r) h = (g - b) / delta + (g < b ? 6.0 : 0.0);
      else if (maxc == g) h = (b - r) / delta + 2.0;
      else h = (r - g) / delta + 4.0;
      h /= 6.0;
    }
    return float4(h, s, l, rgba.w);
  }
  float4 hue2rgb(float hue){
    float r = abs(hue * 6.0 - 3.0) - 1.0;
    float g = 2.0 - abs(hue * 6.0 - 2.0);
    float b = 2.0 - abs(hue * 6.0 - 4.0);
    return float4(r, g, b, 1.0);
  }
  float4 hsl2rgb(float4 hsla) {
    float r = abs(hsla.x * 6.0 - 3.0) -1.0;
    float g = 2.0 - abs(hsla.x * 6.0 - 2.0);
    float b = 2.0 - abs(hsla.x * 6.0 - 4.0);
    float C = (1.0 - abs(2.0 * hsla.z - 1.0)) * hsla.y;
    return float4((float3(r,g,b) - 0.5) * C + hsla.z, hsla.w);
  }

  float4 lerpRGB(float4 c1, float4 c2, float t, float step) {
    float stepT;
    if (step == 0) stepT = t;
    else  stepT = floor(t * step) / (step + 1);
    if (stepT <= 1.0) return lerp(c1, c2, stepT);
    return lerp(c1, c2, stepT);
  }
  float4 lerpHSL_short(float4 c1, float4 c2, float t, float step) {
    float4 hsla1 = rgb2hsl(c1);
    float4 hsla2 = rgb2hsl(c2);
    float stepT;
    if (step == 0) stepT = t;
    else  stepT = floor(t * step) / (step + 1);
    // çŸ­çµŒè·¯è£œæ­£
    if (abs(hsla2.x - hsla1.x) > 0.5) {
      if (hsla1.x > hsla2.x) hsla2.x += 1.0;
      else hsla1.x += 1.0;
    }
    float4 hsla = lerp(hsla1, hsla2, stepT);
    if (hsla.x > 1.0) hsla.x -= 1.0;
    if (hsla.x < 0.0) hsla.x += 1.0;
    return  hsl2rgb(hsla);
  }
  float4 lerpHSL_long(float4 c1, float4 c2, float t, float step) {
    float4 hsla1 = rgb2hsl(c1);
    float4 hsla2 = rgb2hsl(c2);
    float stepT;
    if (step == 0) stepT = t;
    else  stepT = floor(t * step) / (step + 1);
    // çŸ­çµŒè·¯è£œæ­£
    if (abs(hsla2.x - hsla1.x) < 0.5) {
      if (hsla1.x > hsla2.x) hsla2.x += 1.0;
      else hsla1.x += 1.0;
    }
    float4 hsla = lerp(hsla1, hsla2, stepT);
    if (hsla.x > 1.0) hsla.x -= 1.0;
    if (hsla.x < 0.0) hsla.x += 1.0;
    return  hsl2rgb(hsla);
  }
  float4 lerpHSL_r(float4 c1, float4 c2, float t, float step) {
    float4 hsla1 = rgb2hsl(c1);
    float4 hsla2 = rgb2hsl(c2);
    float stepT;
    if (step == 0) stepT = t;
    else  stepT = floor(t * step) / (step + 1);
    if (hsla2.x < hsla1.x) hsla2.x += 1.0;
    float4 hsla = lerp(hsla1, hsla2, stepT);
    if (hsla.x > 1.0) hsla.x -= 1.0;
    if (hsla.x < 0.0) hsla.x += 1.0;
    return  hsl2rgb(hsla);
  }
  float4 lerpHSL_l(float4 c1, float4 c2, float t, float step) {
    float4 hsla1 = rgb2hsl(c1);
    float4 hsla2 = rgb2hsl(c2);
    float stepT;
    if (step == 0) stepT = t;
    else  stepT = floor(t * step) / (step);
    if (hsla1.x > hsla2.x) hsla1.x -= 1.0;
    float4 hsla = lerp(hsla2, hsla1, stepT);
    if (hsla.x > 1.0) hsla.x -= 1.0;
    if (hsla.x < 0.0) hsla.x += 1.0;
    return  hsl2rgb(hsla);
  }

  Texture2D tex : register(t0);
  cbuffer constant0 : register(b0) {
    float str;
    float2 center;
    float angle;
    float width;
    float3 rgb1;
    float a1;
    float3 rgb2;
    float a2;
    float colorSpace;
    float shape;
    float step;
    float gCurve[MaxResolution];
  };
  SamplerState samLinear : register(s0);
  struct PS_INPUT {
    float4 pos : SV_Position;
    float2 uv : TEXCOORD0;
  };

  float4 stepGradient(PS_INPUT input) : SV_Target {
    float original_a = tex.Sample(samLinear, input.uv).a; // å…ƒã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®é€æ˜åº¦
    float4 rgba1 = float4(rgb1 * original_a*a1, a1 * original_a);
    float4 rgba2 = float4(rgb2 * original_a*a2, a2 * original_a);
    float d;
    if (shape == 0) { // ç·šå½¢
      d = dot(input.pos.xy - center, float2(cos(angle), sin(angle))) + width/2.0 + width/step/2;
    }
    else { // å††å½¢
      d = (length(input.pos.xy - center) - angle)*2; // angleã¯å††å½¢ã®å ´åˆå†…å¾„ã¨ã—ã¦æµç”¨
    }
    if (step == 1) { // æ®µéšæ•°ãŒ1ã®å ´åˆã¯å˜ç´”ãª2è‰²å¡—ã‚Šåˆ†ã‘
      if (d < width ) return rgba1;
      else return rgba2;
    }
    if (d < 0 ) return rgba1;
    if (d > width ) return rgba2;
    float mapped_d = gCurve[floor((d)/width * MaxResolution)];
    switch (colorSpace) {
      case 0: // RGBè£œé–“
        return lerpRGB(rgba1, rgba2, mapped_d, step);
      case 1 : // HSLçŸ­çµŒè·¯è£œé–“
        return lerpHSL_short(rgba1, rgba2, mapped_d, step);
      case 2 : // HSLé•·çµŒè·¯è£œé–“
        return lerpHSL_long(rgba1, rgba2, mapped_d, step);
      case 3 : // HSLå³å›ã‚Šè£œé–“
        return lerpHSL_r(rgba1, rgba2, mapped_d, step);
      case 4 : // HSLå·¦å›ã‚Šè£œé–“
        return lerpHSL_l(rgba2, rgba1, mapped_d, step);
      default:
        return lerpRGB(rgba1, rgba2, mapped_d, step);
    }
  }
]]

--ï½¸ï¾ï¾—ï¾ƒï¾æ›²ç·šã‹ã‚‰ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ã‚«ãƒ¼ãƒ–ã®é…åˆ—ã‚’ä½œæˆ
local gCurves = {}
if obj.getoption("track_mode", "3") == 0 then -- æ™‚é–“åˆ¶å¾¡ãŒè¨­å®šã•ã‚Œã¦ã„ãªã„å ´åˆã¯ç›´ç·šç§»å‹•ã¨ã¿ãªã™
  for i = 0, MaxResolution*4 do
    gCurves[i] = i/(MaxResolution*4)
  end
else
  for i = 0, MaxResolution*4 do
    gCurves[i] = obj.getvalue(3,(obj.totaltime-1/obj.framerate)*i/(MaxResolution*4))/100
  end
end

obj.setoption("drawtarget", "tempbuffer", obj.w, obj.h)
if clear == 0 then
  obj.draw()
end
local angle = math.rad(angle_deg) + math.pi/2
if shape == 0 then -- ç·šå½¢ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
  
else -- å††å½¢ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
  angle = angle_deg/2 -- å††å½¢ã®å ´åˆã¯è§’åº¦ã‚’å†…å¾„ã¨ã—ã¦æµç”¨
end
-- ä¸­å¿ƒåº§æ¨™ã‚’è£œæ­£
cx = cx + obj.w / 2
cy = cy + obj.h / 2
-- è‰²ã‚’rgbã«åˆ†è§£
local r1 , g1, b1 = RGB(rgb1)
local r2 , g2, b2 = RGB(rgb2)

obj.pixelshader("stepGradient", "object", "object", {
    str/100.0,
    cx, cy,
    angle,
    width,
    r1/255.0, g1/255.0, b1/255.0,
    1-a1/100.0,
    r2/255.0, g2/255.0, b2/255.0,
    1-a2/100.0,
    colorSpace,
    shape,
    step,
    unpack(gCurves)
  },
  "copy"
)
obj.setoption("blend", BM[blendMode+1])
obj.draw(0,0,0,1.0,str/100.0)
obj.setoption("blend", "none")
obj.copybuffer("obj","tmp")
